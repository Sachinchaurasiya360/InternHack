export interface InterviewQuestion {
  question: string;
  answer: string;
}

export const SKILL_QUESTIONS: Record<string, InterviewQuestion[]> = {
  html: [
    { question: "What is the difference between semantic and non-semantic HTML elements?", answer: "Semantic elements (header, nav, article, section) clearly describe their meaning to both the browser and developer. Non-semantic elements (div, span) tell nothing about their content. Semantic HTML improves accessibility, SEO, and code readability." },
    { question: "What is the purpose of the DOCTYPE declaration?", answer: "DOCTYPE tells the browser which version of HTML the page is written in. In HTML5, <!DOCTYPE html> ensures the browser renders in standards mode rather than quirks mode." },
    { question: "Explain the difference between <script>, <script async>, and <script defer>.", answer: "<script> blocks HTML parsing until the script is downloaded and executed. <script async> downloads in parallel and executes immediately when ready (may run out of order). <script defer> downloads in parallel but executes after HTML parsing is complete, in order." },
    { question: "What are Web Accessibility (a11y) best practices in HTML?", answer: "Use semantic elements, add alt text to images, use proper heading hierarchy, add ARIA labels where needed, ensure keyboard navigation with tabindex, use label elements with form inputs, and maintain proper color contrast." },
    { question: "What is the difference between localStorage and sessionStorage?", answer: "localStorage persists data with no expiration until explicitly cleared. sessionStorage data is cleared when the browser tab is closed. Both store key-value pairs as strings with a ~5MB limit per origin." },
    { question: "Explain the difference between block, inline, and inline-block elements.", answer: "Block elements (div, p, h1) take full width and start on new lines. Inline elements (span, a, strong) only take as much width as needed and don't start new lines. Inline-block elements behave like inline but accept width/height properties." },
  ],
  css: [
    { question: "Explain the CSS Box Model.", answer: "Every element is a rectangular box with: content (the actual content), padding (space between content and border), border (the edge), and margin (space outside the border). box-sizing: border-box includes padding and border in the element's total width/height." },
    { question: "What is the difference between Flexbox and CSS Grid?", answer: "Flexbox is one-dimensional (row OR column) and great for distributing space along a single axis. Grid is two-dimensional (rows AND columns) and ideal for complex page layouts. Use Flexbox for component-level layouts and Grid for page-level layouts." },
    { question: "How does CSS specificity work?", answer: "Specificity determines which CSS rule applies when multiple rules target the same element. The hierarchy is: inline styles (1000) > IDs (100) > classes/attributes/pseudo-classes (10) > elements/pseudo-elements (1). !important overrides all but should be avoided." },
    { question: "What is the difference between em and rem units?", answer: "em is relative to the font-size of the parent element — it compounds with nesting. rem is relative to the root element's font-size (html) — it's consistent regardless of nesting. rem is preferred for predictable sizing." },
    { question: "Explain CSS position values.", answer: "static: default flow. relative: offset from normal position, keeps space. absolute: positioned relative to nearest positioned ancestor, removed from flow. fixed: positioned relative to viewport, stays on scroll. sticky: toggles between relative and fixed based on scroll position." },
    { question: "What are CSS custom properties (variables)?", answer: "CSS variables are defined with -- prefix (e.g., --color-primary: #333) and accessed with var(). They cascade and inherit, can be scoped to selectors, and enable dynamic theming. They're defined on :root for global access." },
  ],
  javascript: [
    { question: "What is the difference between var, let, and const?", answer: "var is function-scoped, hoisted, and can be re-declared. let is block-scoped, hoisted but not initialized (temporal dead zone), can be reassigned. const is block-scoped, must be initialized at declaration, and cannot be reassigned (but object properties can be modified)." },
    { question: "Explain closures in JavaScript.", answer: "A closure is a function that retains access to its outer (lexical) scope variables even after the outer function has returned. This enables data privacy, factory functions, and callbacks that remember their context." },
    { question: "What is the event loop in JavaScript?", answer: "The event loop continuously checks if the call stack is empty, then moves callbacks from the task queue (macrotasks like setTimeout) or microtask queue (Promises) to the call stack. Microtasks have priority over macrotasks. This enables non-blocking async behavior in single-threaded JS." },
    { question: "What is the difference between == and ===?", answer: "== (loose equality) performs type coercion before comparing — '5' == 5 is true. === (strict equality) compares both value AND type without coercion — '5' === 5 is false. Always prefer === to avoid unexpected coercion bugs." },
    { question: "Explain Promises and async/await.", answer: "Promises represent eventual completion/failure of async operations with .then()/.catch(). async/await is syntactic sugar over Promises — async marks a function as returning a Promise, await pauses execution until the Promise resolves. Both handle asynchronous code; async/await provides cleaner, more readable syntax." },
    { question: "What is prototypal inheritance?", answer: "JavaScript uses prototypal inheritance where objects can inherit directly from other objects via the prototype chain. When a property isn't found on an object, JS looks up the prototype chain. Classes in JS are syntactic sugar over this prototype-based system." },
    { question: "What is the difference between map, filter, and reduce?", answer: "map transforms each element and returns a new array of same length. filter returns a new array with elements that pass a test (truthy callback). reduce accumulates array values into a single result using an accumulator and current value." },
  ],
  typescript: [
    { question: "What is the difference between interface and type in TypeScript?", answer: "Both define object shapes, but interfaces support declaration merging (can be extended by re-declaring) and are better for public APIs. Types support unions, intersections, and mapped types. Interfaces use 'extends', types use '&'. For objects, they're mostly interchangeable; for complex types (unions, tuples), use type." },
    { question: "Explain generics in TypeScript.", answer: "Generics allow creating reusable components that work with multiple types while maintaining type safety. E.g., function identity<T>(arg: T): T returns the same type passed in. They enable type-safe collections, API responses, and utility functions without using 'any'." },
    { question: "What are utility types? Name some common ones.", answer: "Utility types transform existing types. Common ones: Partial<T> makes all props optional, Required<T> makes all required, Readonly<T> makes immutable, Pick<T,K> selects specific props, Omit<T,K> removes props, Record<K,V> creates a type with keys K and values V." },
    { question: "What is a discriminated union?", answer: "A discriminated union is a pattern where union members share a common literal property (discriminant) that TypeScript uses for narrowing. E.g., type Shape = { kind: 'circle'; radius: number } | { kind: 'square'; side: number }. Switching on 'kind' narrows the type." },
    { question: "What is the 'never' type in TypeScript?", answer: "never represents values that never occur — functions that always throw, infinite loops, or exhaustive switch cases. It's the bottom type: assignable to everything but nothing is assignable to it. Useful for exhaustiveness checking in switch statements." },
  ],
  react: [
    { question: "What is the Virtual DOM and how does it work?", answer: "The Virtual DOM is a lightweight JavaScript representation of the real DOM. When state changes, React creates a new virtual DOM tree, diffs it with the previous one (reconciliation), and only updates the actual DOM nodes that changed. This batched update approach is more efficient than direct DOM manipulation." },
    { question: "Explain the useEffect hook and its dependency array.", answer: "useEffect runs side effects after render. Empty dependency array [] runs once on mount. Specific dependencies [a, b] re-run when a or b change. No array runs after every render. The cleanup function (returned function) runs before the next effect and on unmount." },
    { question: "What is the difference between controlled and uncontrolled components?", answer: "Controlled components have their value managed by React state via onChange — React is the single source of truth. Uncontrolled components store their own state internally and use refs to read values. Controlled is preferred as it gives you more control over form behavior." },
    { question: "When would you use useMemo and useCallback?", answer: "useMemo memoizes a computed value — use when an expensive calculation runs on every render. useCallback memoizes a function reference — use when passing callbacks to optimized child components (React.memo). Don't overuse them; only optimize when there's a measurable performance issue." },
    { question: "What are React keys and why are they important?", answer: "Keys help React identify which items in a list have changed, been added, or removed. They should be stable, unique identifiers (not array indices). Proper keys enable efficient re-rendering by allowing React to reuse existing DOM elements rather than recreating them." },
    { question: "Explain React Context API vs prop drilling.", answer: "Prop drilling passes data through many component layers that don't use it. Context API provides a way to share values across the component tree without explicit prop passing. Create context with createContext, provide with Provider, consume with useContext. Use for global state like themes, auth, locale." },
  ],
  "node.js": [
    { question: "What is the Node.js event loop?", answer: "Node.js uses a single-threaded event loop that handles I/O operations asynchronously via callbacks/promises. The event loop has phases: timers, I/O callbacks, idle/prepare, poll (new I/O events), check (setImmediate), and close callbacks. This enables handling thousands of concurrent connections without threads." },
    { question: "What is middleware in Express.js?", answer: "Middleware functions have access to req, res, and next. They can execute code, modify request/response, end the request cycle, or call next() to pass control. Types: application-level (app.use), router-level, error-handling (4 args), built-in (express.json), and third-party (cors, helmet)." },
    { question: "Explain the difference between CommonJS and ES Modules.", answer: "CommonJS uses require()/module.exports, is synchronous, loads at runtime, and is Node's original module system. ES Modules use import/export, are asynchronous, statically analyzed at compile time, and support tree-shaking. Use ES Modules (type: module in package.json) for modern Node.js." },
    { question: "How does Node.js handle errors in async code?", answer: "Callbacks use error-first pattern (err, data). Promises use .catch() or try/catch with async/await. Unhandled rejections crash the process in newer Node versions. Express uses error-handling middleware (err, req, res, next). Always handle errors to prevent crashes." },
    { question: "What is the difference between process.nextTick() and setImmediate()?", answer: "process.nextTick() fires before any I/O events in the current iteration of the event loop. setImmediate() fires in the check phase of the next event loop iteration. nextTick has higher priority and can starve I/O if used recursively." },
  ],
  node: [
    { question: "What is the Node.js event loop?", answer: "Node.js uses a single-threaded event loop that handles I/O operations asynchronously via callbacks/promises. The event loop has phases: timers, I/O callbacks, idle/prepare, poll, check, and close callbacks. This enables handling thousands of concurrent connections." },
    { question: "What is middleware in Express.js?", answer: "Middleware functions have access to req, res, and next. They can execute code, modify request/response, end the request cycle, or call next(). Types include application-level, router-level, error-handling, built-in, and third-party middleware." },
    { question: "Explain streams in Node.js.", answer: "Streams handle data in chunks rather than loading everything into memory. Four types: Readable (fs.createReadStream), Writable (fs.createWriteStream), Duplex (sockets), and Transform (zlib). They're memory efficient for large files and enable piping data between sources." },
  ],
  sql: [
    { question: "What is the difference between WHERE and HAVING?", answer: "WHERE filters rows before grouping (works on individual rows). HAVING filters after GROUP BY (works on aggregated results). WHERE can't use aggregate functions; HAVING can. Example: HAVING COUNT(*) > 5 vs WHERE status = 'active'." },
    { question: "Explain different types of JOINs.", answer: "INNER JOIN returns matching rows from both tables. LEFT JOIN returns all rows from left table + matching from right (NULL if no match). RIGHT JOIN is the opposite. FULL OUTER JOIN returns all rows from both (NULL where no match). CROSS JOIN returns cartesian product." },
    { question: "What are indexes and when should you use them?", answer: "Indexes are data structures (usually B-trees) that speed up data retrieval at the cost of slower writes and extra storage. Use on columns in WHERE, JOIN, and ORDER BY clauses. Don't over-index — each index slows INSERT/UPDATE. Use composite indexes for multi-column queries." },
    { question: "Explain database normalization.", answer: "Normalization reduces data redundancy. 1NF: atomic values, no repeating groups. 2NF: 1NF + no partial dependencies on composite keys. 3NF: 2NF + no transitive dependencies. BCNF: every determinant is a candidate key. Denormalization may be used for read performance." },
    { question: "What is a transaction and what are ACID properties?", answer: "A transaction is a unit of work that either fully completes or fully rolls back. ACID: Atomicity (all or nothing), Consistency (valid state to valid state), Isolation (concurrent transactions don't interfere), Durability (committed data survives crashes)." },
  ],
  git: [
    { question: "What is the difference between git merge and git rebase?", answer: "Merge creates a merge commit preserving branch history — non-destructive but creates a complex history. Rebase replays commits on top of the target branch — creates a linear history but rewrites commit hashes. Never rebase public/shared branches." },
    { question: "How do you resolve a merge conflict?", answer: "Git marks conflicts with <<<<<<, =======, >>>>>> markers. Open the file, decide which changes to keep, remove the markers, then git add and git commit. Use git mergetool for a visual diff. Communicate with team members whose changes conflict." },
    { question: "What is git stash and when would you use it?", answer: "git stash temporarily saves uncommitted changes and reverts to a clean working directory. Use when you need to switch branches but aren't ready to commit. git stash pop restores changes, git stash list shows stashed items, git stash drop removes a stash." },
  ],
  python: [
    { question: "What is the difference between a list and a tuple?", answer: "Lists are mutable (can be modified after creation), use square brackets [], and are slightly slower. Tuples are immutable, use parentheses (), are faster, and can be used as dictionary keys. Use tuples for fixed collections, lists for dynamic ones." },
    { question: "Explain Python decorators.", answer: "Decorators are functions that modify the behavior of another function without changing its code. They use @decorator syntax. They take a function as input, add functionality (logging, timing, auth), and return a modified function. Common examples: @property, @staticmethod, @app.route." },
    { question: "What are *args and **kwargs?", answer: "*args allows a function to accept any number of positional arguments as a tuple. **kwargs accepts any number of keyword arguments as a dictionary. Together they make functions flexible: def func(*args, **kwargs). They're commonly used in decorators and wrapper functions." },
    { question: "Explain Python's GIL (Global Interpreter Lock).", answer: "The GIL is a mutex that allows only one thread to execute Python bytecode at a time, even on multi-core CPUs. This limits true parallelism for CPU-bound tasks. Workarounds: use multiprocessing for CPU-bound tasks, threading for I/O-bound tasks, or async/await for concurrent I/O." },
  ],
  docker: [
    { question: "What is the difference between a Docker image and a container?", answer: "An image is a read-only template with application code, runtime, libraries, and dependencies — like a class. A container is a running instance of an image — like an object. Multiple containers can be created from one image, each with its own writable layer." },
    { question: "What is a multi-stage build?", answer: "Multi-stage builds use multiple FROM statements in a Dockerfile. Earlier stages compile/build the application, later stages copy only the artifacts needed. This produces smaller final images by excluding build tools, source code, and dev dependencies." },
    { question: "Explain Docker volumes vs bind mounts.", answer: "Volumes are managed by Docker, stored in Docker's area, and are the preferred mechanism for persistent data. Bind mounts map a host directory directly into the container. Volumes are better for production (portable, backup-friendly); bind mounts are useful for development (live code reloading)." },
  ],
  "machine learning": [
    { question: "What is the bias-variance tradeoff?", answer: "Bias is error from simplistic assumptions (underfitting). Variance is error from sensitivity to training data (overfitting). High bias = poor training performance. High variance = poor generalization. The goal is to find the sweet spot that minimizes total error on unseen data." },
    { question: "Explain cross-validation.", answer: "Cross-validation splits data into k folds, trains on k-1 folds and validates on the remaining one, rotating through all folds. K-fold CV gives a more reliable estimate of model performance than a single train/test split. Common choice is k=5 or k=10." },
    { question: "What is the difference between precision and recall?", answer: "Precision = TP/(TP+FP) — of all predicted positives, how many are actually positive (quality). Recall = TP/(TP+FN) — of all actual positives, how many did we catch (completeness). F1 score is the harmonic mean. Choose based on use case: spam filter needs high precision, disease detection needs high recall." },
  ],
  testing: [
    { question: "What is the difference between unit, integration, and E2E tests?", answer: "Unit tests test individual functions/components in isolation with mocked dependencies. Integration tests test how modules work together. E2E tests simulate real user scenarios through the entire application. The testing pyramid suggests many unit tests, fewer integration, and even fewer E2E tests." },
    { question: "What is mocking and when should you use it?", answer: "Mocking replaces real dependencies with controlled substitutes. Use mocks for: external APIs, databases, timers, random values, and any slow/unpredictable dependency. Mock at boundaries, not implementation details. Over-mocking makes tests brittle and less useful." },
  ],
  security: [
    { question: "What is XSS and how do you prevent it?", answer: "Cross-Site Scripting (XSS) injects malicious scripts into web pages viewed by other users. Prevention: sanitize/escape user input before rendering, use Content-Security-Policy headers, use httpOnly cookies, avoid innerHTML, and use frameworks that auto-escape output (React, Angular)." },
    { question: "Explain the difference between authentication and authorization.", answer: "Authentication verifies WHO you are (login, credentials, identity). Authorization determines WHAT you can do (permissions, roles, access control). Authentication comes first, then authorization. Example: logging in is authentication; checking if you can delete a post is authorization." },
    { question: "What is CSRF and how do you prevent it?", answer: "Cross-Site Request Forgery tricks users into performing unwanted actions on sites where they're authenticated. Prevention: CSRF tokens (unique per session/request), SameSite cookie attribute, checking Origin/Referer headers, and requiring re-authentication for sensitive actions." },
  ],
  "data structures": [
    { question: "What is the time complexity of operations on a hash table?", answer: "Average case: O(1) for insert, delete, and lookup. Worst case: O(n) when all keys hash to the same bucket (collision). Good hash functions and proper load factor management (resizing) keep operations near O(1)." },
    { question: "When would you use a stack vs a queue?", answer: "Stack (LIFO): undo operations, function call stack, expression evaluation, backtracking algorithms, browser history. Queue (FIFO): task scheduling, BFS traversal, message queues, print queue, handling requests in order." },
    { question: "Explain the difference between a Binary Tree and a Binary Search Tree.", answer: "A Binary Tree has at most 2 children per node with no ordering. A BST maintains the property: left child < parent < right child. BST enables O(log n) search, insert, delete when balanced. Without balancing, a BST can degrade to O(n) — a linked list." },
  ],
  algorithms: [
    { question: "Explain the difference between BFS and DFS.", answer: "BFS (Breadth-First Search) explores all neighbors at current depth before going deeper — uses a queue, finds shortest path in unweighted graphs. DFS (Depth-First Search) explores as far as possible along each branch before backtracking — uses a stack/recursion, uses less memory." },
    { question: "What is dynamic programming?", answer: "DP solves complex problems by breaking them into overlapping subproblems and storing results to avoid redundant computation. Two approaches: top-down (memoization with recursion) and bottom-up (tabulation with iteration). Key: identify optimal substructure and overlapping subproblems." },
    { question: "What is the time complexity of common sorting algorithms?", answer: "Bubble/Selection/Insertion: O(n²) average/worst. Merge Sort: O(n log n) always, O(n) space. Quick Sort: O(n log n) average, O(n²) worst. Heap Sort: O(n log n) always, O(1) space. Counting/Radix Sort: O(n+k) for bounded integers." },
  ],
  dbms: [
    { question: "What is normalization and why is it important?", answer: "Normalization is the process of organizing a database to reduce redundancy and dependency. 1NF ensures atomic values, 2NF removes partial dependencies, 3NF removes transitive dependencies, BCNF ensures every determinant is a candidate key. It reduces data anomalies (insert, update, delete) and improves data integrity." },
    { question: "What is the difference between DBMS and RDBMS?", answer: "DBMS stores data as files without relationships between tables. RDBMS stores data in tabular form with relationships (foreign keys) between tables, supports ACID properties, uses SQL, and enforces data integrity through constraints. Examples: DBMS — file systems; RDBMS — MySQL, PostgreSQL, Oracle." },
    { question: "Explain ACID properties in a database.", answer: "Atomicity: a transaction is all-or-nothing. Consistency: database moves from one valid state to another. Isolation: concurrent transactions don't interfere with each other. Durability: once committed, data survives system failures. These properties ensure reliable transaction processing." },
    { question: "What are different types of keys in a database?", answer: "Primary Key: uniquely identifies each row. Foreign Key: references a primary key in another table. Candidate Key: minimal set of attributes that can uniquely identify a row. Super Key: any set that uniquely identifies rows. Composite Key: primary key made of multiple columns. Alternate Key: candidate key not chosen as primary key." },
    { question: "What is indexing and what are its types?", answer: "Indexing creates a data structure to speed up data retrieval. Types: Primary Index (on primary key), Secondary Index (on non-key attributes), Clustered Index (data physically sorted by index), Non-Clustered Index (separate structure pointing to data), Dense Index (entry for every record), Sparse Index (entry for every block)." },
    { question: "Explain different types of joins in SQL.", answer: "INNER JOIN: returns matching rows from both tables. LEFT JOIN: all rows from left + matching from right. RIGHT JOIN: all from right + matching from left. FULL OUTER JOIN: all rows from both tables. CROSS JOIN: cartesian product. SELF JOIN: a table joined with itself. NATURAL JOIN: auto-joins on common column names." },
    { question: "What is a deadlock in DBMS? How can it be prevented?", answer: "A deadlock occurs when two or more transactions wait for each other to release locks, creating a cycle. Prevention methods: Lock ordering (acquire locks in consistent order), Timeout-based (abort after timeout), Wait-Die and Wound-Wait schemes, Two-Phase Locking with deadlock detection using wait-for graphs." },
  ],
  "computer network": [
    { question: "Explain the OSI model and its 7 layers.", answer: "Layer 1 Physical: bits over media. Layer 2 Data Link: frames, MAC addressing, error detection. Layer 3 Network: IP addressing, routing. Layer 4 Transport: TCP/UDP, end-to-end delivery. Layer 5 Session: session management. Layer 6 Presentation: encryption, compression, translation. Layer 7 Application: HTTP, FTP, DNS, user interface." },
    { question: "What is the difference between TCP and UDP?", answer: "TCP is connection-oriented, reliable (guaranteed delivery with acknowledgments), ordered, has flow/congestion control, and is slower (HTTP, FTP, email). UDP is connectionless, unreliable (no guaranteed delivery), unordered, faster, and has lower overhead (DNS, video streaming, gaming, VoIP)." },
    { question: "What happens when you type a URL in the browser?", answer: "1) Browser checks cache, then DNS resolution (recursive query to resolve domain to IP). 2) TCP three-way handshake (SYN, SYN-ACK, ACK). 3) TLS handshake if HTTPS. 4) HTTP request sent. 5) Server processes and sends response. 6) Browser parses HTML, loads CSS/JS, renders the page. 7) Connection may be kept alive or closed." },
    { question: "Explain the difference between IPv4 and IPv6.", answer: "IPv4: 32-bit addresses (4.3 billion), dotted decimal (192.168.1.1), header 20-60 bytes, uses NAT. IPv6: 128-bit addresses (3.4×10³⁸), hexadecimal with colons (2001:db8::1), header fixed at 40 bytes, built-in IPSec, no NAT needed, auto-configuration via SLAAC." },
    { question: "What is subnetting and why is it used?", answer: "Subnetting divides a large network into smaller logical sub-networks. It improves security (isolate segments), reduces broadcast traffic, optimizes IP address usage, and simplifies management. A subnet mask (e.g., 255.255.255.0 or /24) determines which part of the IP is the network vs host portion." },
    { question: "Explain ARP (Address Resolution Protocol).", answer: "ARP maps an IP address (Layer 3) to a MAC address (Layer 2) within a local network. The sender broadcasts an ARP request asking 'Who has this IP?'. The device with that IP responds with its MAC address. This mapping is cached in the ARP table for future use. RARP does the reverse (MAC to IP)." },
    { question: "What is the three-way handshake in TCP?", answer: "Step 1: Client sends SYN (synchronize) packet with an initial sequence number. Step 2: Server responds with SYN-ACK (synchronize-acknowledge), acknowledging client's SYN and sending its own sequence number. Step 3: Client sends ACK, acknowledging server's SYN. Connection is now established and data transfer can begin." },
  ],
  "computer fundamental": [
    { question: "What is the difference between RAM and ROM?", answer: "RAM (Random Access Memory) is volatile — data is lost when power is off. It's read-write, faster, and used for active programs. ROM (Read Only Memory) is non-volatile — data persists without power. It stores firmware/BIOS. Types of RAM: SRAM, DRAM. Types of ROM: PROM, EPROM, EEPROM." },
    { question: "Explain the Von Neumann architecture.", answer: "Von Neumann architecture has: CPU (ALU + Control Unit), Memory (stores both data and instructions), Input/Output devices, and a Bus system connecting them. Instructions are fetched from memory, decoded, and executed sequentially. The bottleneck is that data and instructions share the same memory bus." },
    { question: "What is the difference between compiler and interpreter?", answer: "Compiler translates entire source code to machine code before execution, produces an executable file, shows all errors at once, and runs faster (C, C++, Java). Interpreter translates and executes line by line, no separate file, shows errors one at a time, and is slower but easier to debug (Python, JavaScript, Ruby)." },
    { question: "What is cache memory and how does it work?", answer: "Cache is a small, very fast memory between CPU and RAM that stores frequently accessed data. It uses locality of reference — temporal (recently accessed data) and spatial (nearby data). Levels: L1 (smallest, fastest, on CPU), L2 (larger, slightly slower), L3 (largest, shared among cores). Cache hit = data found; cache miss = fetch from RAM." },
    { question: "Explain number systems and conversions.", answer: "Binary (base 2): uses 0,1. Octal (base 8): uses 0-7. Decimal (base 10): uses 0-9. Hexadecimal (base 16): uses 0-9, A-F. Conversion: decimal to binary — divide by 2, collect remainders. Binary to decimal — multiply each bit by 2^position. 1 hex digit = 4 binary bits. 1 octal digit = 3 binary bits." },
    { question: "What are logic gates and their types?", answer: "Logic gates perform boolean operations on binary inputs. AND: output 1 only if all inputs are 1. OR: output 1 if any input is 1. NOT: inverts input. NAND: NOT AND (universal gate). NOR: NOT OR (universal gate). XOR: output 1 if inputs differ. XNOR: output 1 if inputs are same. NAND and NOR can implement any circuit." },
  ],
  "operating system": [
    { question: "What is a process vs a thread?", answer: "A process is an independent program in execution with its own memory space, file handles, and resources. A thread is the smallest unit of execution within a process — threads share the process's memory and resources. Creating threads is lighter than processes. Context switching between threads is faster. Processes communicate via IPC; threads share memory directly." },
    { question: "Explain different CPU scheduling algorithms.", answer: "FCFS: first come, first served — simple but causes convoy effect. SJF: shortest job first — optimal average wait time but needs burst prediction. Round Robin: time quantum-based preemption — fair but high context switching. Priority: based on priority values — may cause starvation (solve with aging). Multilevel Queue: separate queues for different process types." },
    { question: "What is virtual memory?", answer: "Virtual memory extends physical RAM by using disk space (swap/page file). Each process gets a virtual address space mapped to physical memory via page tables. Benefits: run programs larger than physical RAM, memory isolation between processes, efficient memory allocation. Concepts: paging, page faults, page replacement algorithms (LRU, FIFO, Optimal)." },
    { question: "Explain deadlock: conditions and prevention.", answer: "Deadlock occurs when processes wait indefinitely for resources held by each other. Four necessary conditions (Coffman): 1) Mutual Exclusion — resource held exclusively. 2) Hold and Wait — holding one, waiting for another. 3) No Preemption — can't forcibly take resources. 4) Circular Wait — circular dependency chain. Prevent by breaking any one condition." },
    { question: "What is paging and segmentation?", answer: "Paging divides memory into fixed-size pages (logical) and frames (physical). Simple, no external fragmentation, but has internal fragmentation. Segmentation divides memory into variable-size segments based on logical divisions (code, data, stack). More meaningful, supports sharing, but causes external fragmentation. Modern systems combine both." },
    { question: "Explain different types of operating systems.", answer: "Batch OS: jobs processed in batches without user interaction. Time-Sharing OS: CPU time shared among multiple users (Unix). Real-Time OS: guaranteed response within deadlines (RTOS for embedded systems). Distributed OS: manages multiple computers as one system. Network OS: provides network services. Mobile OS: Android, iOS for mobile devices." },
    { question: "What is the difference between mutex and semaphore?", answer: "Mutex (Mutual Exclusion): binary lock, only the thread that locked it can unlock it, used for exclusive resource access. Semaphore: integer counter, can be signaled by any thread. Binary semaphore is similar to mutex but without ownership. Counting semaphore allows N concurrent accesses. Mutex prevents priority inversion with priority inheritance." },
  ],
  hld: [
    { question: "What is High-Level Design and how does it differ from Low-Level Design?", answer: "HLD defines the system architecture — components, their interactions, data flow, and technology choices at a macro level. It answers WHAT the system does and HOW components communicate. LLD dives into the implementation details — class diagrams, database schemas, API contracts, and algorithms. HLD is for architects; LLD is for developers." },
    { question: "How would you design a URL shortener like bit.ly?", answer: "Components: Load Balancer → Web Servers → Application Servers → Database + Cache. Use Base62 encoding of auto-increment ID or hash for short URLs. Store mapping in a relational DB (key-value). Use Redis cache for hot URLs. Read-heavy system (100:1 read:write). Add analytics service for click tracking. Scale with database sharding on short URL hash." },
    { question: "Explain the CAP theorem with examples.", answer: "CAP states a distributed system can guarantee only 2 of 3: Consistency (all nodes see same data), Availability (every request gets a response), Partition Tolerance (system works despite network failures). CP: MongoDB, HBase — consistent but may be unavailable during partitions. AP: Cassandra, DynamoDB — available but may return stale data. CA: only in single-node systems (traditional RDBMS)." },
    { question: "How would you design a chat application like WhatsApp?", answer: "Use WebSocket connections for real-time messaging. Components: Chat Server (manages WebSocket connections), Message Queue (Kafka for async delivery), Presence Service (online/offline status), Media Service (S3 for images/videos), Notification Service (push for offline users). Use message queues for guaranteed delivery. Store messages in Cassandra (write-heavy, time-series). Last-seen using heartbeats." },
    { question: "What is database sharding and when would you use it?", answer: "Sharding horizontally partitions data across multiple database instances. Each shard holds a subset of data. Strategies: Hash-based (consistent hashing on user ID), Range-based (by date, geography), Directory-based (lookup table). Use when: single DB can't handle load, need horizontal scaling. Challenges: cross-shard queries, rebalancing, maintaining consistency." },
    { question: "How do you ensure high availability in system design?", answer: "Redundancy: multiple instances of every component. Load balancing: distribute traffic (active-active or active-passive). Database replication: master-slave or multi-master. Auto-scaling: handle traffic spikes. Health checks: detect and route around failures. CDN: cache static content at edge. Circuit breakers: prevent cascade failures. Geographic distribution: multi-region deployment." },
  ],
  lld: [
    { question: "What are SOLID principles?", answer: "S — Single Responsibility: a class should have one reason to change. O — Open/Closed: open for extension, closed for modification. L — Liskov Substitution: subtypes must be substitutable for base types. I — Interface Segregation: prefer small, specific interfaces over large ones. D — Dependency Inversion: depend on abstractions, not concretions." },
    { question: "Design a parking lot system.", answer: "Classes: ParkingLot (floors, entry/exit points), ParkingFloor (spots list), ParkingSpot (type: compact/large/handicapped, isAvailable), Vehicle (type, licensePlate), Ticket (entryTime, spot, vehicle), Payment (amount, method). Patterns: Strategy for pricing, Factory for spot assignment. Use enums for VehicleType and SpotType. ParkingLot uses Singleton pattern." },
    { question: "Explain common design patterns with examples.", answer: "Creational: Singleton (DB connection), Factory (create objects without exposing logic), Builder (construct complex objects step-by-step). Structural: Adapter (convert interface), Decorator (add behavior dynamically), Facade (simplified interface). Behavioral: Observer (event handling), Strategy (interchangeable algorithms), Command (encapsulate requests)." },
    { question: "Design a library management system.", answer: "Classes: Library, Book (ISBN, title, author, copies), Member (id, name, membership), Librarian extends Member. BookItem (individual copy, rack location). BookLending (issueDate, dueDate, returnDate). Fine (amount, paid). Key methods: searchBook(), issueBook(), returnBook(), calculateFine(). Use Observer pattern to notify members when reserved book is available." },
    { question: "What is the difference between composition and inheritance?", answer: "Inheritance (IS-A): subclass extends superclass, inherits behavior. Tight coupling, changes in parent affect children. Composition (HAS-A): class contains instances of other classes. Loose coupling, more flexible, easier to test. Prefer composition over inheritance — it's more modular and avoids the fragile base class problem. Use inheritance only for true IS-A relationships." },
    { question: "Design an elevator system.", answer: "Classes: ElevatorSystem (manages multiple elevators), Elevator (currentFloor, direction, state), Request (floor, direction), Button (InternalButton, ExternalButton), Door. Use State pattern for elevator states (Moving, Idle, Stopped). Strategy pattern for scheduling algorithm (SCAN, LOOK, SSTF). Queue for pending requests. ElevatorSystem assigns requests to optimal elevator based on proximity and direction." },
  ],
  aptitude: [
    { question: "A train 300m long passes a pole in 15 seconds. What is its speed?", answer: "Speed = Distance / Time = 300m / 15s = 20 m/s. Convert to km/h: 20 × (18/5) = 72 km/h. Key formula: To convert m/s to km/h, multiply by 18/5. When a train passes a pole, the distance covered equals the length of the train." },
    { question: "If A can do a job in 12 days and B can do it in 18 days, how long will they take together?", answer: "A's rate = 1/12 per day. B's rate = 1/18 per day. Combined rate = 1/12 + 1/18 = 3/36 + 2/36 = 5/36 per day. Time = 36/5 = 7.2 days. Formula: If A takes 'a' days and B takes 'b' days, together they take (a×b)/(a+b) days." },
    { question: "What is the probability of getting at least one head in 3 coin tosses?", answer: "P(at least one head) = 1 - P(no heads) = 1 - P(all tails) = 1 - (1/2)³ = 1 - 1/8 = 7/8. The complement approach is easier: instead of calculating P(1H) + P(2H) + P(3H), calculate 1 - P(0H). This works for any 'at least' probability problem." },
    { question: "A man invests Rs 10,000 at 10% compound interest for 2 years. Find the amount.", answer: "Formula: A = P(1 + R/100)^n = 10000(1 + 10/100)² = 10000 × (1.1)² = 10000 × 1.21 = Rs 12,100. Compound Interest = A - P = Rs 2,100. Simple Interest would be Rs 2,000. CI is always more than SI for n > 1 year." },
    { question: "In how many ways can 5 people be arranged in a row?", answer: "This is a permutation problem. n people in a row = n! = 5! = 5 × 4 × 3 × 2 × 1 = 120 ways. If arranged in a circle, it would be (n-1)! = 4! = 24 ways. If some are identical, divide by the factorial of the repeats." },
    { question: "Two pipes A and B can fill a tank in 20 and 30 minutes. A drain pipe C can empty it in 15 minutes. If all three are open, how long to fill?", answer: "A's rate = 1/20, B's rate = 1/30, C's rate = -1/15 (negative because it empties). Combined = 1/20 + 1/30 - 1/15 = 3/60 + 2/60 - 4/60 = 1/60 per minute. Time = 60 minutes. When the drain rate exceeds fill rate, the tank will never fill." },
    { question: "A boat goes 24 km upstream in 6 hours and 24 km downstream in 4 hours. Find the speed of the boat and stream.", answer: "Upstream speed = 24/6 = 4 km/h. Downstream speed = 24/4 = 6 km/h. Speed of boat in still water = (downstream + upstream)/2 = (6+4)/2 = 5 km/h. Speed of stream = (downstream - upstream)/2 = (6-4)/2 = 1 km/h." },
  ],
};

export function getQuestionsForSkill(skillName: string): InterviewQuestion[] {
  const lower = skillName.toLowerCase().trim();
  if (SKILL_QUESTIONS[lower]) return SKILL_QUESTIONS[lower];
  for (const [key, questions] of Object.entries(SKILL_QUESTIONS)) {
    if (lower.includes(key) || key.includes(lower)) return questions;
  }
  const words = lower.split(/[\s./\\-]+/);
  for (const word of words) {
    if (word.length > 2 && SKILL_QUESTIONS[word]) return SKILL_QUESTIONS[word];
  }
  return [];
}

export function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}
